
MVC PATTERN
On the server, there are rich Model classes that represent every entity. For many-to-many relationships, a separate Model is created.

Definitions: A Model is defined with Fields. An Instance is a Model with one set of specific data. Some Fields may be a Collection of other Model Instances, or a single reference to another Model Instance. All Model Instances have an Id, but most also have a Slug, which is a humanreadable identified based off the name or title of the Instance.

A Model can be acted upon. These are:
Model->LIST: Return all (or filtered) list of Instances in Model.
Model->NEW: Create a new Instance of the Model.
Instance->VIEW: View an Instance of the Model.
Instance->DELETE: Permanently delete an Instance of a Model (relationships to it may need to be dealt with)
Instance->EDIT: Update fields in an Instance of a Model.
Instance->Custom: Custom actions on this Instance.
Instance->Collection->Add: Adds Instances to a Collection in this Instance.
Instance->Collection->Remove: Adds Instances to a Collection in this Instance.

There are three layers to the application. On a URL level, we use a REST-like (but not correct) URL scheme that is based on the model name. It looks as follows:

URL SCHEME
/<model>s/							GET:list all
/<model>s/new						GET:form for new		POST:create new instance
/<model>s/<id>						GET:view of instance	POST:Update instance (PUT) (DELETE)
/<model>s/<id>/delete				GET:user prompts		POST:delete instance
/<model>s/<id>/<custom>				GET:user prompt 		POST:do it
/<model>s/<id>/<collection>/add 	GET:user prompt			POST: add Instances identified in args
/<model>s/<id>/<collection>/remove	GET:user prompt			POST: remove Instances identified in args

Formal REST (ignored in this case)
GET    /people               list members
POST   /people               create member
GET    /people/1             retrieve member
PUT    /people/1             update member
DELETE /people/1             delete member

We use GET for non-state-changing operations, and POST for state changing operations. The GET for a state changing operation normally responds with the form or user prompt that is needed before POSTing the update. The response to a POST is either an error, a redirection to the updated Instance VIEW, or the Instances that were changed in HTML or JSON format (to be inserted by the client in the appropriate place).

HANDLER SCHEME
Each URL pattern points to a handler, e.g. function, that performs business logic, database lookup (e.g. Model interaction) and starts rendering. Althouh each URL pattern has it's own function, not all are doing any specific operations - many redirect to a more generic handler.
So, for most Models, the mapping will be like this:
/<model>s/	 						--> <model>_list()

/<model>s/new
/<model>s/<id>
/<model>s/<id>/delete 				--> <model>_edit()

/<model>s/<id>/<collection>/add		
/<model>s/<id>/<collection>/remove	--> <model>_<collection>_change()

The reason is that the logic and the subsequent rendering will have many similarities for an Instance of a Model, as well as the removing or adding to a collection.

TEMPLATE SCHEME
When we render, we have many different scenarios to deal with. In general, a specific page can be served in three different ways:
- Full page load with all needed parts included as needed.
DOCUMENT (main HTML, header, footers)
	SECTION (section content, sidebar, text, etc)
		HEADER
		<MODEL VIEW> (one or many dynamic views to interact with, e.g. lists, tables, etc.)
			<INSTANCEs> (representations of an instance and the actions to take on it)
		FOOTER

- Modal view: the main content, without surrounding markup, that can be inserted into modal or iframe
HEADER
<MODEL VIEW>
FOOTER

- Partial: An HTML or JSON representation of one or many instances of same Model, to be inserted dynamically on the client. This can for example return only one row relating to a particular model (e.g. if we add a new model instance to the list, this will return only that model HTML)
<MODEL VIEW> (without e.g. header and footer markup)

We want to avoid duplicating the template code needed. We want to also avoid, where possible, splitting up the content too much. The more generic parts of the page are higher up in the hierarchy, and the more specific (dense) parts are towards the Instance.
We also want to support, when needed, dynamic rendering of Model Views. That means, that the Model View is rendered on client only based on JSON representation of the Model objects.
However, some pages will include many different model views. So when we render the response, we cannot render Model View and let it extend all generic hierarchies. We will need to render the Modal view, while extending upwards and including downwards. So:

- base.html
	- <section>.html // e.g. "Social")
		{% block something %}{% endblock %} // Variables to set later, e.g. Title, Flash, Script-load
		- <page>.html // e.g. "Friends")
			{% if not modal %}{% extends social.html %}
			{% else %}{{ set some modal parameters }}{% endif %}
			{% include modelA_view.html %}
			Custom content
			{% include modelB_view.html %}
				- model_B_view.html
					{% if partial extend "partial.html" else %}
						<model view header>
					{% endif %}
					{% for instances %}
					<instance>
					{% endfor %}
					{% if not partial %}
						<model view actions, footer>
					{% endif %}

MODEL VIEW HTML STRUCTURE
So a Model View is a dynamic view of model instances. It can be a single instance, or a collection of them (e.g. list). 
.m_view
	.m_instance // descendant of m_view, shows an instance of the model (e.g. a row in a table)
		.m_field/ descendant of m_instance, holds a particular field of the instance. Can also be a collection.
		.m_collection // if a view is instance an instance, it is a sub-view, e.g. of items in a collection field.
				// actions here work on the inner view, and does not know about the enclosing larger view
				// in sub-views, it is normally not legal to do new or delete. E.g. if a user has two groups, 
				// our intention is not normally to create or delete a group but instead to add or remove it from the user
			.m_instance //
				.m_action   // if we are inside an instance, add or remove will either completely remove the instance tag or add
							// a new instance tag
			.m_selection
				.m_action	// if we are inside a selection, add or remove will select and deselect the instance in place, instead
							// of removing/adding it
			.m_action
		.m_selector // a selector is different from a view, in that when we add and remove items, we simply select or deselect
					// which means to leave the item in place but change it's rendering
	.m_action // descendant of m_view, button or a that invokes an action on the whole view, normally "add" or custom actions


<div .m_list>
	<div .m_instance #id>
		<div .m_field .m_[name]>value</div>
		OR
		<div .m_field .m_[name] data-value=value>Text</div>
		OR
		<div .m_list .m_[name]>
			<div .m_instance #id></div>
		</div>

		<div .m_actions>
			<a .m_action></a>
			<a .m_action></a>
		</div>
	</div>
</div>

<div .m_list .m_list_users>
	<div .m_instance .m_instance_users #m_marco>
		<div .m_field .m_field-username data-value=marco>[...thumbnailetc...]</div>
		<div .m_field .m_field-realname>Marco B</div>
		<div .m_field .m_field-location>Location</div>
		<div .m_actions>
			<a .m_action .m_action-follow href=/follow></a>
			<a .m_action .dropdown .m_action-changegroup>
				<ul .m_collection #m_masteredgroups>
				<li>
			</a>
			<a .m_action .m_action-sendmessage href=/conversation></a>
		</div>
	</div>
	<div .m_action></div>
</div>

Questions
- How to edit in place? How to edit when only parts of the fields are visible?
- How to deal with multiple selects? Both "selected" and "available". Selected is the many-to-many field of an instance. Available is a "collection".
- How to deal with actions that changes state on themselves?

Writeup
A page shows views of models. A view is a representation of 1 to n instances of a model, e.g. "User".
The view is a HTML node in itself. All instances are children (not direct?) of the model view.
Fields of the model instance is children nodes of the instance.
So, a table can be the model view, the instance each row and the field each cell.
A model view or instance does not have to show all available instances or fields of that model.
There may be a subset. Some fields may also be additional, e.g. there can be pure presentation nodes in between.
This means that the HTML representation of a field or instance should be enough to at least identify it, if not to carry all information known about it.

Each instance represents an ID on the server. This is given by the class .m_id-xxx . It has to be a class because
there may be multiple representations of the same instance on the same page (and the id attribute has to be unique).

A model instance can also contain action links. An action is a A or BUTTON that is a child of the model view.
The model view will always deal with the action, but some are defined on a per instance basis, some are defined in the view.

This is defined in the view:
/new	If not in new mode, this will show the form for a new instance. If in new mode, and the POST is successful, it will add the new
		instance as the last child to the view. If failed, it will display a message, and go back to inactive mode.

This is defined per instance.
/edit	If not in edit mode, this will swap the sending instance to a form (replace divs with inputs, etc). If in edit mode, this will
		instead stop edit mode and replace the instance with the new information, if the POST was successful, or revert, if it failed.
/remove	If not in remove mode, activate it by showing a prompt. If in remove mode, and the POST was successful, it will remove the instance from the view.

An action corresponds (and is identified by) the keyword at the end of its URL, given by HREF. This means that you can always fall back on going to the link to take the action.

When changes are made to an instance as above, it may also be necessary to propagate those changes. Every other instance with same ID, or model view with 
same ID, will be updated as well. (consider doing this lazily, e.g. only load the new instance if the view is shown).

A model can also have custom actions. These also correspond to a URL for GET and POST. For example, "send message", "follow", etc. Usually these actions
relate to what the current user can do with them. Custom actions will need to be defined to be handled on a per model view class basis.

Type of action presentations:
One-click	If the actions needs no prompt nor user input, this button simply executes a POST to action URL and changes presentation accordingly.
In-place	This all fields of an instance node into input fields in a form. This requires user input.
Modal		This will launch a modal that essentially contains a form. This is for prompts or edits that cannot be made in place, or when we need to get 			 the form from the server.

What is common between actions is this:
- They are a A or BUTTON element with a href
- When clicked/activated, they will trigger an event
- The event will be caught by the encompassing model view
- The model view will use the calling element, it's attributes and sometimes it children nodes as the input information needed.
- The action will be in the following states. Inactive -> Activated ->(POST)-> Success -> (GET) -> (change presentation) -> Inactive
- An action can in some cases skip the inactive state, for example if it is a

Server vs client role
The server will decide which actions are available and what filter or fields are shown. The client can not add or change this. It can only do incremental changes to what was given by the server. This means, no authorization or access control is done on the client. The server will validate the POST of each action and either accept or deny it. It will also have to send back information to the client on what it ended up deciding. That means, it has to respond with the resource resulting from the POST. For example, a new, add or remove can be interpreted differently in the server or cause some other state change in the model that has to be updated.


Collection fields
Most fields are single variable, e.g. a textstring or integer. But some are collection fields. This means that the field value is chosen as one or several items from a collection. Typical example is the multiselect component of a form. It can be groups that a user is member of, etc.
The selected value(s) is the value of the field. In a form, each selected value will be added to the POST data. (TODO - treat the available values as a model view, meaning it can change during use, e.g. add or remove available groups).

When we add or remove in collections as actions. In some cases, we may only want to show the selected items in the list. Sometimes we want to show all available, and simply select or deselect.

v selected  (-)
notselected (+) 


USER LIST
u.username 	u.realname 	u.location	LIST:Add to			(delete)	(edit)	(msg)
									(-) Groupname (status)
									(+) Groupname (status)
(new)

GROUP DETAIL

MEMBER LIST:g.members[] 
	(-) gm.member.username	gm.member.realname	gm.status
	(+)
g.name
g.location
g.description

CONVERSATION LIST
c.messages[0:20]	c.mod_date	c.members
(new)

FAMILY_TREE
a.name	CHILDREN LIST:a.children[]
		(-) a.name
		(-) a.name
		(+)

LIST
	new
	delete
	edit
COLLECTION
	(+) add
	(-) remove

Partial HTML:
+ Minimal logic on client
- Server needs to know the exact formatting of requesting code, as one model can be represented in many ways
- Little replication on server if done correctly

JSON, rendered by functions on client
+ Generic to handle on server (but may still need to "render" JSON differently for different pages)
- Not really lightweight as we need to serve the functions to render along with each view at some point
- Some replication as same template should create HTML as well as a function

JSON, full blown model and template on client:
+ Much less server logic required
- Takes more time to load from client
- May still not have the capabilities of manipulating models as on the server side




TEMPLATES
Full page:
- doc
	- body
		- header
		- content
			- model view
				- instance(s)
		- footer

Modal page: (to be inserted in a modal popup or iframe)
- header
- content
	- model view
		- instance(s)
- footer

Partial page: (an HTML snippet to be inserted into a model view)


WORLD


Types of articles

- Person
Metadata:
++ Gender
++ Born
++ Home -> Place
++ Images -> URL

- Place
++ Type (country, building, etc)
++ Born
++ Inside -> Place
++ Contains -> Place*

- Event

- Item

- Other



- instance(s)