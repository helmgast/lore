from hashlib import md5
import datetime
from wtfpeewee.orm import model_form, ModelConverter
from flask_peewee.auth import BaseUser
from flask_peewee.utils import slugify
from peewee import *
from peewee import RawQuery
from wtforms import fields as f

from app import db

# WTForms would treat the _absence_ of a field in POST data as a reason to
# to set the data to empty. This is a problem if the same POST receives variations
# to a form. This method removes form fields if they are not present in postdata.
# This means the form logic will not touch those fields in the actual objects.
def matches_form(formclass, formdata):
    for k in formdata.iterkeys():
        if k in dir(formclass):
            print "Matches field %s!" % k
            return True
    return False

class Conversation(db.Model):
    #creator = ForeignKeyField(User)
    modified_date = DateTimeField(default=datetime.datetime.now)
    
    def members(self):
        return User.select().join(ConversationMembers).where(ConversationMembers.conversation == self)
        
    def last_message(self):
        msgs = list(Message.select().where(Message.conversation == self).order_by(Message.pub_date.desc()).limit(1))
        if len(msgs)==0:
            return None
        return msgs[0]
        
    def add_members(self, members):
        for m in members:
            cm = ConversationMembers.create(member=m, conversation=self)
            m.log("was added to conversation %s" % self.id)
    
# A user in the system
class User(db.Model, BaseUser):
    username = CharField()
    password = CharField()
    email = CharField()
    realname = CharField()
    location = CharField(null=True)
    description = TextField(null=True)
    exp = IntegerField(default=0)
    join_date = DateTimeField(default=datetime.datetime.now)
    msglog = ForeignKeyField(Conversation)
    active = BooleanField(default=True)
    admin = BooleanField(default=False)

    def __unicode__(self):
        return self.username

    def save(self, *args, **kwargs):
        print "args, %s, kwargs %s" % (args, kwargs)
        try:
            self.msglog.get()
        except Conversation.DoesNotExist:
            print "No log, creating"
            self.msglog = Conversation.create()
            print "Now have %s" % self.msglog.id
        return super(User, self).save(*args, **kwargs)

    def full_string(self):
        return "%s (%s)" % (self.username, self.realname)
     
    def log(self, msg):
        print self.username,msg
        Message.create(user=self, content=msg, conversation=self.msglog)

    # Users that this user follows
    def following(self):
        return User.select().join(
            Relationship, on=Relationship.to_user
        ).where(Relationship.from_user == self).order_by(User.username.asc())

    # Users that follows this user
    def followers(self):
        return User.select().join(
            Relationship, on=Relationship.from_user
        ).where(Relationship.to_user == self).order_by(User.username.asc())
    
    def is_following(self, user):
        return Relationship.filter(
            from_user=self,
            to_user=user
        ).exists()
        
    def get_most_recent_conversation_with(self, recipients):
        # A private conversation is one which is only between this user
        # and the given recipients, with no other users
        if not recipients:
            raise ValueError('Empty list of recipients')
        if not isinstance(recipients, list) or not isinstance(recipients[0], User):
            raise TypeError('Expects a list of User')
        print "recipients is list of %s, first item is %s" % (type(recipients[0]), recipients[0])
        member_ids = [self.id]+[i.id for i in recipients] # add this user as well

        rq = RawQuery(Conversation, 
            'SELECT c.id, c.modified_date FROM conversation c INNER JOIN \
            conversationmembers a ON a.conversation_id = c.id WHERE a.member_id IN (?%s) GROUP BY \
            a.conversation_id HAVING COUNT(*) = ( SELECT COUNT(*) FROM conversationmembers b \
            WHERE b.conversation_id = a.conversation_id GROUP BY b.conversation_id) AND COUNT(*) = ? \
            ORDER BY c.modified_date DESC;' % ',?'*(len(member_ids)-1),
            *(member_ids+[len(member_ids)]))
        # NOTE, the query need to include a ? for each parameter, so we need to insert enough ? to match
        # our number of members. We also need to insert the number of members as a parameter itself,
        # into the last function argument, in the *params style (expand list into separate arguments)
        #print rq.sql(db.get_compiler())
        return rq

    def gravatar_url(self, size=48):
        return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' %\
               (md5(self.email.strip().lower().encode('utf-8')).hexdigest(), size)

# An autogenerated form class for doing validation and POST / form processing
UserForm = model_form(User, exclude=['password','admin', 'active', 'exp','username', 'join_date'])

class ConversationMembers(db.Model):
    member = ForeignKeyField(User)
    conversation = ForeignKeyField(Conversation)

# A gamer group, e.g. people who regularly play together. Has game masters
# and players
class Group(db.Model):
    name = CharField()
    location = CharField()
    slug = CharField()
    description = CharField()
    conversation = ForeignKeyField(Conversation)
    
    def __unicode__(self):
        return self.slug

    # Need to add *args, **kwargs for some arcane reason
    def save(self, *args, **kwargs):
        self.slug = slugify(self.name)
        try:
            self.conversation.get()
        except Conversation.DoesNotExist:
            print "No conversation, creating"
            self.conversation = Conversation.create()
            print "Now have %s" % self.conversation.id
        return super(Group, self).save(*args, **kwargs)
    
    # def create(self, *args, **kwargs):
    #     self.conversation = Conversation.create()
    #     return super(Group, self).create(*args, **kwargs)

    def masters(self):
        return User.select().join(GroupMember).where(GroupMember.group == self, GroupMember.status == GROUP_MASTER)
    def players(self):
        return User.select().join(GroupMember).where(GroupMember.group == self, GroupMember.status == GROUP_PLAYER)
    def invited(self):
        return User.select().join(GroupMember).where(GroupMember.group == self, GroupMember.status == GROUP_INVITED)
    def members(self):
        return GroupMember.select().where(GroupMember.group == self).order_by(GroupMember.status.asc())

    def get_member(self, user):
        return GroupMember.get(member=user,group=self)

    def addMembers(self, newmembers, type):
        if not newmembers or not isinstance(newmembers[0], User):
            raise TypeError("Need a list of Users, got %s of type %s" % (newmembers, type(newmembers)))
        if not type in STATUSES.keys():
            raise TypeError("type need to be one predefined integers, see models.py")
        members_dict = dict([[gm.member.id,gm] for gm in GroupMember.select().where(GroupMember.group == self)])
        edited = []
        for u in newmembers:
            if u.id in members_dict:
                if type==GROUP_MASTER and members_dict[u.id].status == GROUP_PLAYER: # Upgrade user to master
                    members_dict[u.id].status = GROUP_MASTER
                    members_dict[u.id].save()
                    edited.append(members_dict[u.id])
                    u.log("was upgraded to Master of %s" % self.slug)
            else:
                edited.append(GroupMember.create(group=self, member=u, status=type))
                u.log("was added to group %s" % self.slug)
        return edited

    def removeMembers(self, members):
        if not members or not isinstance(members[0], User):
            raise TypeError("Need a list of Users, got %s of type %s" % (members, type(members)))
        removed = []
        for gm in GroupMember.select().where(GroupMember.group == self, GroupMember.member << members): # in members
            removed.append(gm)
            cm = ConversationMembers.get(conversation=self.conversation, member=gm.member)
            gm.member.log("was removed from group %s" % self.slug)
            gm.delete_instance()
            cm.delete_instance() # Remove the user from the group conversation as well
        return removed
                
# An autogenerated form class for doing validation and POST / form processing
GroupForm = model_form(Group, exclude=['slug', 'conversation'])
        
# The relationship between a user as member of a Group
GROUP_MASTER, GROUP_PLAYER, GROUP_INVITED = 1,2,3
STATUSES = {GROUP_MASTER:'master', GROUP_PLAYER:'player', GROUP_INVITED:'invited'}
class GroupMember(db.Model):
    group = ForeignKeyField(Group)
    member = ForeignKeyField(User)
    status = IntegerField(choices=((GROUP_MASTER, 'master'), (GROUP_PLAYER, 'player'), (GROUP_INVITED, 'invited')))
    
    def __unicode__(self):
        return "%s, %s in %s" % (self.member, self.status_text(), self.group)

    def save(self, *args, **kwargs):
        if self.member not in self.group.conversation.members():
            self.group.conversation.add_members([self.member])
        return super(GroupMember, self).save(*args, **kwargs)

    def status_text(self):
        return STATUSES[self.status]

# The directional relationship between two users, e.g. from_user follows to_user
class Relationship(db.Model):
    from_user = ForeignKeyField(User, related_name='relationships')
    to_user = ForeignKeyField(User, related_name='related_to')

    def __unicode__(self):
        return 'Relationship from %s to %s' % (self.from_user, self.to_user)
        
# A message from a user (to everyone)
class Message(db.Model):
    user = ForeignKeyField(User)
    content = TextField()
    pub_date = DateTimeField(default=datetime.datetime.now)
    conversation = ForeignKeyField(Conversation, default=0)
    #readable_by = IntegerField(choices=((1, 'user'), (2, 'group'), (3, 'followers'), (4, 'all')))

    def __unicode__(self):
        return '%s: %s' % (self.user, self.content)
            
# All material related to a certain story.
class Campaign(db.Model):
    name = CharField()
    slug = CharField()
    world = CharField() # The game world this belongs to
    group = ForeignKeyField(Group)
    rule_system = CharField()
    description = TextField(null=True)
    archived = BooleanField(default=False) # If the campaign is archived
    def __unicode__(self):
        return self.name

    def save(self, *args, **kwargs):
        self.slug = slugify(self.name)
        return super(Campaign, self).save(*args, **kwargs)

    def load_scene_tree(self, scene_tree, parent=None):
        # TODO very inefficient implementation
        o = 1
        for s in scene_tree:
            print "Found %s, updating to o=%s, parent=%s" % (s, o, parent)
            q = Scene.update(order=o, parent=parent).where(Scene.id == s['id'])
            print q.execute()
            o += 1
            if 'children' in s:
                self.load_scene_tree(s['children'], parent=Scene.get(Scene.id == s['id'])) 


CampaignForm = model_form(Campaign, exclude=['slug'])

# A part of a Scenario, that can be in current focus of a game
class Scene(db.Model):
    campaign = ForeignKeyField(Campaign)
    parent = ForeignKeyField('self', related_name='children', null=True)
    name = CharField()
    description = CharField(null=True)
    order = IntegerField() # The integer order between scenes

    def ordered_children(self):
        return self.children.order_by(Scene.order.asc())

SceneForm = model_form(Campaign, exclude=['order', 'parent', 'campaign'])
                
# A game session that was or will be held, e.g. the instance between a scenario
# and a group at a certain date
class Session(db.Model):
    play_start = DateTimeField()
    play_end = DateTimeField()
    campaign = ForeignKeyField(Campaign, related_name='sessions')
    description = CharField(null=True) # Details on the event if any.
    location = CharField(null=True) # Location of the session

SessionForm = model_form(Session, exclude=[])

# Lists users present at a particular session
class SessionPresentUser(db.Model):
    present_user = ForeignKeyField(User)
    session = ForeignKeyField(Session)
            
class GeneratorInputList(db.Model):
    name = CharField()

    def items(self):
        return GeneratorInputItem.select().where(GeneratorInputItem.input_list == self)

class GeneratorInputItem(db.Model):
    input_list = ForeignKeyField(GeneratorInputList)
    content = CharField()

class StringGenerator(db.Model):
    name = CharField()
    description = TextField(null=True)
    generator = None

    def __unicode__(self):
        return self.name

class World(db.Model):
    name = CharField()
    # startyear = 0
    # daysperyear = 360
    # datestring = "day %i in the year of %i" 
    # calendar = [{name: january, days: 31}, {name: january, days: 31}, {name: january, days: 31}...]

ARTICLE_DEFAULT, ARTICLE_MEDIA, ARTICLE_PERSON, ARTICLE_FRACTION, ARTICLE_PLACE, ARTICLE_EVENT = 0, 1, 2, 3, 4, 5

class Article (db.Model):
    type = IntegerField(default=ARTICLE_DEFAULT, choices=((ARTICLE_DEFAULT, 'default'), (ARTICLE_MEDIA, 'media'), (ARTICLE_PERSON, 'person'), (ARTICLE_FRACTION, 'fraction'), (ARTICLE_PLACE, 'place'), (ARTICLE_EVENT, 'event')))
    title = CharField()
    slug = CharField() # URL-friendly name
    content = TextField()
    # publish_status = IntegerField(choices=((1, 'draft'),(2, 'revision'), (3, 'published')), default=1)
    created_date = DateTimeField(default=datetime.datetime.now)
    # modified_date = DateTimeField()
    world = ForeignKeyField(World)
    metadata = TextField() # JSON
    # thumbnail

class MediaArticle (db.Model):
    mime_type = CharField()
    url = CharField()

GENDER_UNKNOWN, GENDER_MALE, GENDER_FEMALE = 0, 1, 2

class PersonArticle (db.Model):
    article = ForeignKeyField(Article)
    born = IntegerField()
    died = IntegerField()
    gender = IntegerField(default=GENDER_UNKNOWN, choices=((GENDER_UNKNOWN, 'unknown'), (GENDER_MALE, 'male'), (GENDER_FEMALE, 'female')))
    # otherNames = CharField()
    occupation = CharField()

class FractionArticle (db.Model):
    article = ForeignKeyField(Article)

class PlaceArticle (db.Model):
    article = ForeignKeyField(Article)
    coordinate_x = FloatField() # normalized position system, e.g. form 0 to 1 float, x and y
    coordinate_y = FloatField() # 
    location_type = CharField() # building, city, domain, point_of_interest

class EventArticle (db.Model):
    article = ForeignKeyField(Article)
    from_date = IntegerField()
    to_date = IntegerField()

class RelationTypes (db.Model):
    name = CharField() # human friendly name
    # code = CharField() # parent, child, reference, 
    # display = CharField() # some display pattern to use for this relation, e.g. "%from is father to %to"
    # from_type = # type of article from
    # to_type = # type of article to 

class ArticleRelations (db.Model):
    from_article = ForeignKeyField(Article)
    to_article = ForeignKeyField(Article)
    relation_type = ForeignKeyField(RelationTypes)
    # twosided = False, True

# class ArticleRights (db.Model):
    # user = ForeignKeyField(User)
    # article = ForiegnKeyField(Article)
    # right = ForiegnKeyField(UserRights)

# class UserRights (db.Model):
    # right = # owner, editor, reader


# relation examples
#class Article(db.Model):
#    title = CharField()
#    slug = CharField() # URL-friendly name
#    content = TextField()
#    status = IntegerField(choices=((1, 'draft'),(2, 'revision'), (3, 'published')), default=1)
#    #category = IntegerField(choices=((1, 'world'), (2, 'person'), (3, 'rule')))
#    created_date = DateTimeField(default=datetime.datetime.now)
#    modified_date = DateTimeField()
#    style = CharField(null=True) # URI to stylesheet to activate when displaying
#    image = CharField(null=True) # URI to an image-ID that shows up as icon, thumbnail, etc
#    
#    # For self-referring keys, we need this line as the object self is not created
#    # when creating this. See http://peewee.readthedocs.org/en/latest/peewee/fields.html#self-referential-foreign-keys
#    parent = ForeignKeyField('self', related_name='children', null=True)
#
#    class Meta:
#        order_by = ('modified_date',)
#
#    def __unicode__(self):
#        return self.title
#
#    def save(self, ):
#        self.slug = slugify(self.title)
#        self.modified_date = datetime.datetime.now()
#        return super(Article, self).save()
#        
#class Metadata(db.Model): # Metadata to any article
#    article = ForeignKeyField(Article)
#    key = CharField()
#    value = CharField()
#


'''
@ link to
& embed
# revision
World:Mundana
    &Text:...  (always a leaf node)
    &Media:... (also always a leaf node)
    @Place:Consaber
        @Place:Nantien
            @Person:Tiamel
            @Place:Nant
                #rev67
                #rev66
                ...
    Event:Calniafestivalen
    Scenario:Calniatrubbel
        &Text:...
        @Scene:1
            @/mundana/consaber/nantien
            @/mundana/
        @Scene:2
        @Scene:3
    Character:Taldar

Semantical structure
World:Mundana
    Place:Consaber mundana/consaber
        Place:Nantien mundana/consaber/nantien
            Person:Tiamel mundana/consaber/nantien/tiamel
            Place:Nant mundana/consaber/
    Event:Calniafestivalen
    Scenario:Calniatrubbel
        Scene:1
            @/mundana/consaber/nantien
            @/mundana/
        Scene:2
        Scene:3
    Character:Taldar

'''